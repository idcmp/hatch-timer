#summary Getting Started with Hatch (with Maven2)
#labels Featured,Phase-Implementation

= Introduction =

Hatch is very easy to get going into your own projects.  This page will walk you through the initial steps of getting it going.  Start here if you want to try Hatch out for your own projects.  I assume you have a working application already that you want to try this on.

= Details =

We'll get you to include hatch in your project, update your code, then we'll see the results!  

== Maven ==

First start by adding our maven repository to your project.  Add to your pom.xml:

{{{
  <repositories>
    <repository>
      <id>hatch-maven2-repo</id>
      <name>Hatch: Maven Repository on Google Code</name>
      <url>http://hatch-timer.googlecode.com/svn/repo</url>
    </repository>
  </repositories>
}}}

Then include hatch as a dependency:

{{{
  <dependencies>
    <dependency>
      <groupId>org.linuxstuff.hatch</groupId>
      <artifactId>hatch-core</artifactId>
      <version>1.0-SNAPSHOT</version>
    </dependency>
  </dependencies>
}}}

That's it!  If you need to *idea:idea* or *eclipse:eclipse* do it now.

== Your Code ==

Find some code you want to discover the performance breakdown on.  If you don't have any, create a test class that has some methods in it that call {{{Thread.sleep()}}}.

The proper pattern for introducing Hatch is to add the push/pop calls *in actual method*, not wrap calls to the method.  This is important to follow in large projects for consistency.

===Before===

So you've found some code:

{{{

  public void businessMethod(BusinessBean bizBean) {
     validateRequest(bizBean);
     doFirstBusinessThing(bizBean.getParam());
     doLastBusinessThing(bizBean.getParam());
  }
}}}

===After===

We'll ignore exception handling for our first cut:

{{{
  public void businessMethod(BusinessBean bizBean) {
     TimerStackUtil.enableAndPush("businessMethod");
     validateRequest(bizBean);
     doFirstBusinessThing(bizBean.getParam());
     doLastBusinessThing(bizBean.getParam());
     TimerStackUtil.pop("businessMethod");

  }
}}}

You want to add similar calls in {{{validateRequest}}} {{{doFirstBusinessThing}}} and {{{doLastBusinessThing}}} too.  You can use {{{TimerStackUtil.push()}}} instead in those classes.

That's it.  No really.

== Running ==

Compile and start your project.  When a call to {{{businessMethod}}} completes, you will see:

{{{
  [160ms] businessMethod
   [80ms] validateRequest
   [20ms] doFirstBusinessThing
   [30ms] doLastBusinessThing
}}}

In the above example,  you may notice these values do not sum up correctly. This means that 10ms are spent in {{{businessMethod}}} itself.

= Conclusion =

I know, that was pretty simple, but you now have a basic understanding of how to use Hatch.  If this seems interesting to you, see the DetailedIntroduction for more details.